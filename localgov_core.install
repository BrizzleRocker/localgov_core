<?php

use Drupal\field\Entity\FieldStorageConfig;
use Drupal\field\Entity\FieldConfig;
use Drupal\Core\Config\FileStorage;
use Drupal\Core\Entity\Entity\EntityViewDisplay;
use Drupal\Core\Entity\Entity\EntityFormDisplay;

/**
 * Update Field storage for core fields email_address, facebook, phone, twitter.
 */
function localgov_core_update_8001(&$sandbox) {
  // Update field tables, Based on :
  //   https://blog.42mate.com/change-field-type-with-existing-data-on-drupal-8/
  $database = \Drupal::database();
  $entity_type = 'node';

  // See https://drupal.stackexchange.com/a/276209
  $config_path    = drupal_get_path('module', 'localgov_core') . '/config/install';
  $source         = new FileStorage($config_path);
  $config_storage = \Drupal::service('config.storage');
  $config_factory = \Drupal::configFactory();

  // Update each field.
  $field_names = ['email_address', 'facebook', 'phone', 'twitter'];
  foreach ($field_names as $field_name_unprefixed) {
    $old_field_name = 'field_' . $field_name_unprefixed;
    $new_field_name = 'localgov_' . $field_name_unprefixed;
    $old_table = $entity_type . '__' . $old_field_name;
    $new_table = $entity_type . '__' . $new_field_name;
    $revision_old_table = $entity_type . '_revision__' . $old_field_name;
    $revision_new_table = $entity_type . '_revision__' . $new_field_name;
    $old_table_value_column = $old_field_name . '_value';
    $new_table_value_column = $new_field_name . '_value';
    $field_storage = FieldStorageConfig::loadByName($entity_type, $old_field_name);

    // Get install new field config.
    $config_name = 'field.storage.' . $entity_type . '.' . $new_field_name;
    $config_storage->write($config_name, $source->read($config_name));
    //
    // Rename the table.
    // $sql = "RENAME TABLE $old_table TO $new_table, $revision_old_table TO $revision_new_table";
    // $database->query($sql);
    // Clone the table.
    $sql[] = "DROP TABLE IF EXISTS $new_table";
    $sql[] = "DROP TABLE IF EXISTS $revision_new_table";
    $sql[] = "CREATE TABLE $new_table LIKE $old_table";
    $sql[] = "INSERT INTO $new_table SELECT * FROM $old_table";
    $sql[] = "CREATE TABLE $revision_new_table LIKE $revision_old_table";
    $sql[] = "INSERT INTO $revision_new_table SELECT * FROM $revision_old_table";
    $sql[] = "ALTER TABLE $new_table CHANGE $old_table_value_column $new_table_value_column varchar(255)";
    $sql[] = "ALTER TABLE $revision_new_table CHANGE $old_table_value_column $new_table_value_column varchar(255)";
    foreach ($sql as $indv_sql) {
      $database->query($indv_sql);
    }

    // Update the field config in other nodes where used.
    $config_manager = Drupal::service('config.manager');
    $field_storage_name = $field_storage->getConfigDependencyName();
    $dependents = $config_manager->findConfigEntityDependentsAsEntities('config', [$field_storage_name]);
    foreach ($dependents as $dependent) {
      /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface $dependent */
      if ($dependent instanceof FieldConfig) {
        $new_field = $dependent->toArray();
        unset($new_field['uuid']);
        unset($new_field['_core']);
        $new_field['field_name'] = $new_field_name;
        $new_field['id'] = str_replace($old_field_name, $new_field_name, $new_field['id']);
        $new_field['dependencies']['config'][0] = str_replace($old_field_name, $new_field_name, $new_field['dependencies']['config'][0]);
        $new_field = FieldConfig::create($new_field);
        $new_field->original = $dependent;
        $new_field->enforceIsNew(TRUE);
        $new_field->save();
      }
    }

    foreach ($dependents as $dependent) {
      /** @var \Drupal\Core\Config\Entity\ConfigEntityInterface $dependent */
      if ($dependent instanceof EntityViewDisplay || $dependent instanceof EntityFormDisplay) {
        if ($component = $dependent->getComponent($old_field_name)) {
          $dependent->setComponent($new_field_name, $component);
          $groups = $dependent->getThirdPartySettings('field_group');
          foreach ($groups as $group_key => $group) {
            foreach($group['children'] as $child_key => $child) {
              if ($child == $old_field_name) {
                $group['children'][$child_key] = $new_field_name;
                $dependent->setThirdPartySetting('field_group', $group_key, $group);
              }
            }
          }
        }
      }
      $dependent->save();
    }

    // Deleting field storage which will also delete bundles(fields).
    // $field_storage->delete();
  }

  // Remove the old config after all renaming is done,
  // as otherwise table not found errors occur.
  foreach ($field_names as $field_name_unprefixed) {
    $old_field_name = 'field_' . $field_name_unprefixed;
    $field_storage = FieldStorageConfig::loadByName($entity_type, $old_field_name);
    $field_storage->delete();
  }
}
